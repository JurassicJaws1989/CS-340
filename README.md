# CS-340 - Justin Smith
SNHU Client Server Development
# How do you write programs that are maintainable, readable, and adaptable? 
There are many ways to improve programs with the way you write them. This helps not only yourself with organzing your thoughts, but others when they try to 
take over where you left off. Here are some of the ways to ensure that code is maintainable, readable, and adaptable,
* Choose descriptive names for variables, functions, classes, and methods. Names should clearly convey their purpose and intent, making the code easier to understand.
* Adhere to coding standards and style guides relevant to your programming language.
* Keep functions small and focused on doing one thing well (Single Responsibility Principle). This makes functions easier to understand, test, and maintain.
* Use comments to explain why the code exists, its purpose, and how it works. Documentation helps other developers (and your future self!) understand the code without needing to decipher every detail.
* Implement unit tests to validate the functionality of individual components (functions, classes) of your code. Automated tests ensure correctness during refactoring and modifications.
* Conduct and participate in code reviews to gather feedback from peers. Code reviews promote knowledge sharing, identify potential issues early, and improve overall code quality.

with the CRUD file from this project in mind, adhering to the above methods adds immense benefits. For example, the way that this function was developed, it could easily be utilized in other
programs that require create, read, update, and delete functionality. The comments are clear, so it could potentially benefit others if needed.

# How do you approach a problem as a computer scientist?
Approaching a problem as a computer scientist involves applying systematic and analytical thinking to devise solutions that are efficient, scalable, and effective. This means breaking down and
understanding the overall problem statement, developing algorithms to begin to come to a solution. After this, comes the implementation and problem solving.


